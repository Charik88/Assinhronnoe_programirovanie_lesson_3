/*Задание 1
 Сортировка выбором

     Реализуйте алгоритм сортировки выбором.
     Сортировка выбором состоит в том, что в неупорядоченном списке находится наименьший элемент. Выбранный в исходном списке минимальный элемент записывается на i-е место исходного списка (i=1,2,…,п), а элемент с i-го места — на место выбранного. При этом очевидно, что уже упорядоченные элементы, а они будут расположены, начиная с первого места, исключаются из дальнейшей сортировки, поэтому длина списка, участвующего в каждом последующем просмотре, должна быть на один элемент меньше предыдущего.
     Поиск минимального элемента реализуйте в виде асинхронной задачи.
     Результат должен возвращаться в основной поток через связку std::promise-std::future.
*/


#include <iostream>
#include <vector>
#include <thread>
#include <future>
#include <algorithm>

int findMinIndex(const std::vector<int>& arr, int start, int end) { // функция для поиска минимального индекса в массиве
    int minIndex = start; // инициализируем индекс минимального элемента как начальный индекс
    for (int i = start + 1; i < end; ++i) { // перебираем элементы массива, начиная с индекса start + 1
        if (arr[i] < arr[minIndex]) { // если текущий элемент меньше минимального элемента
            minIndex = i; // обновляем индекс минимального элемента
        }
    }
    return minIndex; // возвращаем индекс минимального элемента
}

void selectionSort(std::vector<int>& arr) { // функция для сортировки выбором
    for (int i = 0; i < arr.size() - 1; ++i) { // перебираем элементы массива, кроме последнего
        // Создаем promise и future для получения индекса минимального элемента
        std::promise<int> promiseMinIndex; // создаем промис
        std::future<int> futureMinIndex = promiseMinIndex.get_future(); // получаем future для получения индекса минимального элемента

        // Запускаем асинхронную задачу для поиска минимального элемента
        std::thread([&, i, promise = std::move(promiseMinIndex)]() mutable { // передаем promiseMinIndex  в асинхронную задачу
            int minIndex = findMinIndex(arr, i, arr.size()); // вызываем функцию для поиска минимального элемента
            promise.set_value(minIndex); // устанавливаем значение промиса
        }).detach();  // Поток будет работать независимо

        // Получаем индекс минимального элемента
        int minIndex = futureMinIndex.get();

        // Меняем местами текущий элемент и минимальный
        std::swap(arr[i], arr[minIndex]);
    }
}

void printArray(const std::vector<int>& arr) { // ф-ия для вывода массива
    for (const int& num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> arr = {64, 25, 12, 22, 11}; // инициализация массива

    std::cout << "Исходный массив: ";
    printArray(arr); // вывод исходного массива

    selectionSort(arr); // сортировка выбором

    std::cout << "Отсортированный массив: ";
    printArray(arr); // вывод отсортированного массива

    return 0;
}

